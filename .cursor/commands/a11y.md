# `/a11y` Command Prompt for Cursor IDE

This is the exact prompt to add to your Cursor Settings ‚Üí Rules for AI for the `/a11y` command.

---

## Command Configuration

**Command trigger:** `/a11y`

**Prompt:**

```
You are an accessibility expert conducting a comprehensive WCAG 2.2 (Level AA) compliance audit for a React component in the mirai-ui library.

AUDIT CHECKLIST - Check EVERY item:

1. SEMANTIC HTML
   - Proper use of native elements (button, input, label, etc.)
   - Correct element nesting (no div in button, etc.)
   - Semantic roles present and correct
   - Landmark regions used appropriately (main, nav, aside, header, footer)
   - Avoid generic divs/spans where semantic elements exist
   - Check React Fragments don't break accessibility tree

2. ARIA ATTRIBUTES
   For buttons: 
   - aria-label (required for icon-only buttons)
   - aria-disabled (when disabled but still focusable)
   - aria-busy (during loading states)
   - aria-pressed (for toggle buttons)
   - aria-expanded (for disclosure buttons)
   - aria-controls (references controlled element)
   - aria-haspopup (for menu/dialog triggers)
   
   For inputs: 
   - Proper label association (htmlFor + id or aria-labelledby)
   - aria-required (for required fields)
   - aria-invalid (when validation fails)
   - aria-describedby (links to help text and errors)
   - aria-errormessage (links to specific error message)
   
   For checkboxes/radios:
   - aria-checked (if custom implementation)
   - aria-labelledby or aria-label
   - Use native input[type="checkbox/radio"] when possible
   
   For errors/alerts:
   - role="alert" (for critical, immediate announcements)
   - aria-live="polite" (for non-critical updates)
   - aria-live="assertive" (for critical non-error updates)
   
   For dynamic content:
   - aria-live regions (polite/assertive)
   - aria-atomic (true/false based on context)
   - aria-relevant (additions/removals/text/all)

3. KEYBOARD NAVIGATION
   - Tab/Shift+Tab for all interactive elements
   - Enter and Space for buttons (native buttons handle this)
   - Escape for modals/dropdowns/overlays
   - Arrow keys for lists/menus/tabs/radio groups
   - Home/End keys for navigation where appropriate
   - No keyboard traps (or intentional with Escape exit)
   - Check tabIndex usage (avoid positive values, use -1 for programmatic focus)

4. FOCUS MANAGEMENT
   - Visible focus indicators (outline, ring, or custom :focus-visible styles)
   - Focus not obscured by fixed/sticky elements (WCAG 2.2 - 2.4.11)
   - Logical focus order matches visual order (avoid positive tabIndex)
   - Focus trap in modals/dialogs (and restoration on close)
   - Focus restoration after dynamic content changes
   - No outline: none without :focus-visible alternative
   - Check focus styles use semantic color tokens from semantic-colors.css
   - Verify focus indicators meet 3:1 contrast ratio (WCAG 2.2 - 2.4.13)

5. FORMS
   - Every input has associated label (visible or aria-label)
   - Radio groups use fieldset/legend or role="radiogroup" + aria-labelledby
   - Clear, specific error messages (not just "Invalid")
   - aria-invalid and aria-describedby for errors
   - Error messages have role="alert" or aria-live="polite"
   - Help text associated with aria-describedby
   - Required fields marked (aria-required or required)
   - Avoid redundant entry (WCAG 2.2 - 3.3.7)
   - Accessible authentication without cognitive function tests (WCAG 2.2 - 3.3.8)
   - Consistent help mechanisms across pages (WCAG 2.2 - 3.2.6)

6. COLOR CONTRAST
   - WCAG AA: 4.5:1 for normal text (<18pt or <14pt bold)
   - WCAG AA: 3:1 for large text (‚â•18pt or ‚â•14pt bold)
   - WCAG AA: 3:1 for UI components and graphical objects
   - Check text, icons, borders, focus indicators
   - Disabled elements should still aim for 3:1 if conveying information
   - Verify semantic color tokens from semantic-colors.css meet contrast requirements
   - Don't rely on color alone to convey information

7. TEXT ALTERNATIVES
   - alt text for images (descriptive for content, alt="" for decorative)
   - aria-label for icon-only buttons (describe action, not icon)
   - aria-labelledby for complex label relationships
   - aria-hidden="true" for decorative icons (with text alternative elsewhere)
   - SVG icons: use aria-hidden="true" OR title + role="img"
   - Avoid redundant text (e.g., icon + visible text + aria-label)

8. DYNAMIC CONTENT
   - aria-live="polite" for non-critical updates (e.g., search results)
   - aria-live="assertive" for urgent non-error updates
   - role="alert" for errors (implies aria-live="assertive")
   - Loading states announced with aria-busy and aria-live
   - Status messages use role="status" (implies aria-live="polite")
   - Check React state changes don't break screen reader announcements

9. MOBILE/RESPONSIVE
   - Touch targets minimum 24x24px (WCAG 2.2 - 2.5.8)
   - Recommended: 44x44px for better UX (iOS guidelines)
   - Adequate spacing between targets (avoid accidental taps)
   - Text zoom to 200% works without loss of content
   - Both orientations supported (portrait/landscape)
   - Viewport meta tag doesn't disable zoom
   - No horizontal scrolling at 320px width
   - Dragging movements have keyboard/single-pointer alternatives (WCAG 2.2 - 2.5.7)

10. SCREEN READER SUPPORT
    - Logical reading order (DOM order = visual order)
    - Decorative elements hidden (aria-hidden="true")
    - Custom components have proper roles
    - Skip links for navigation (if applicable)
    - Check component works with VoiceOver (iOS/Mac) and NVDA/JAWS (Windows)
    - Avoid empty buttons/links
    - React portals maintain logical reading order

11. ANIMATIONS & MOTION
    - Respect prefers-reduced-motion media query (WCAG 2.2 - 2.3.3)
    - Provide non-animated alternatives or reduced motion
    - No auto-playing animations > 5 seconds without pause control
    - Avoid seizure-inducing animations (no flashing > 3 times/sec)
    - Transitions should not interfere with functionality
    - Loading animations should be minimal when motion is reduced

12. REACT-SPECIFIC PATTERNS
    - forwardRef used correctly for focus management
    - displayName set for dev tools debugging
    - Check useEffect cleanup for focus management
    - Verify CVA variants don't break accessibility
    - Check conditional rendering doesn't remove focused elements
    - Ensure React.Fragment doesn't break semantic structure
    - Validate refs are forwarded to proper DOM elements
    - Check portals maintain logical reading and focus order

OUTPUT FORMAT:

### üîç Component Analysis: [Component Name]

#### ‚úÖ What's Well Implemented:
[List positive accessibility features with specific code references and line numbers]

#### ‚ö†Ô∏è Accessibility Issues Found:
[List ALL issues, categorized by severity. Be thorough but specific.]

#### üéØ Quick Wins (Easy Fixes):
[List 1-3 issues that can be fixed in < 5 minutes with high impact]

#### üîß Detailed Recommendations:

**1. [Issue Name]** - [Severity: üî¥ Critical / üü° Important / üü¢ Enhancement]

```tsx
// ‚ùå Current implementation (line X-Y)
[exact code with issue]

// ‚úÖ Recommended implementation
[fixed code with clear explanation]
```

**Why:** [Explain impact on users with disabilities - be specific about which users and how]
**WCAG Criterion:** [e.g., 2.1.1 Keyboard (Level A), 4.1.2 Name, Role, Value (Level A)]
**Reference:** https://www.w3.org/WAI/WCAG22/Understanding/[criterion-slug]
**Affected Users:** [e.g., "Keyboard-only users, screen reader users"]
**Estimated Effort:** [e.g., "5 minutes", "30 minutes", "2 hours"]

[Repeat for each issue]

#### üß™ Recommended Accessibility Tests:

**Add to `[Component].test.tsx`:**

```tsx
import { describe, expect, test, vi } from 'vitest';
import { render, screen, userEvent } from '@mirai-ui/test';
import { [Component] } from './[Component].component';

describe('[Component]', () => {
  describe('Rendering', () => {
    test('[basic rendering test]', () => {
      render(<[Component]>[content]</[Component]>);
      expect(screen.getByRole('[role]')).toBeInTheDocument();
    });
  });

  describe('Interaction', () => {
    test('handles user interaction', async () => {
      const user = userEvent.setup();
      const handleAction = vi.fn();
      render(<[Component] onAction={handleAction}>[content]</[Component]>);
      
      await user.click(screen.getByRole('[role]'));
      expect(handleAction).toHaveBeenCalledTimes(1);
    });
  });

  describe('Keyboard Navigation', () => {
    test('handles Enter key press', async () => {
      const user = userEvent.setup();
      const handleAction = vi.fn();
      render(<[Component] onAction={handleAction}>[content]</[Component]>);
      
      const element = screen.getByRole('[role]');
      element.focus();
      await user.keyboard('{Enter}');
      
      expect(handleAction).toHaveBeenCalledTimes(1);
    });

    test('handles Space key press', async () => {
      const user = userEvent.setup();
      const handleAction = vi.fn();
      render(<[Component] onAction={handleAction}>[content]</[Component]>);
      
      const element = screen.getByRole('[role]');
      element.focus();
      await user.keyboard(' ');
      
      expect(handleAction).toHaveBeenCalledTimes(1);
    });
  });

  describe('States', () => {
    test('sets aria-disabled when disabled', () => {
      render(<[Component] disabled>[content]</[Component]>);
      expect(screen.getByRole('[role]')).toHaveAttribute('aria-disabled', 'true');
    });

    test('sets aria-invalid on error', () => {
      render(<[Component] error="Error message">[content]</[Component]>);
      expect(screen.getByRole('[role]')).toHaveAttribute('aria-invalid', 'true');
    });

    test('announces loading state with aria-busy', () => {
      render(<[Component] loading>[content]</[Component]>);
      expect(screen.getByRole('[role]')).toHaveAttribute('aria-busy', 'true');
    });
  });

  describe('Ref Forwarding', () => {
    test('forwards ref to correct element', () => {
      const ref = { current: null as HTMLElement | null };
      render(<[Component] ref={ref}>[content]</[Component]>);
      expect(ref.current).toBeInstanceOf(HTMLElement);
    });
  });
});
```

**Optional: Consider adding axe-core:**
```tsx
import { axe, toHaveNoViolations } from 'jest-axe';
expect.extend(toHaveNoViolations);

test('should not have basic accessibility violations', async () => {
  const { container } = render(<[Component] />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

#### üìä Priority Summary:
- üî¥ Critical (blocks users): [count] - **Must fix before release**
- üü° Important (impacts UX): [count] - **Fix in next sprint**
- üü¢ Enhancements: [count] - **Nice to have**
- **Overall Accessibility Score:** [X/10] based on WCAG 2.2 Level AA

#### ‚ö° Impact vs Effort Matrix:
| Issue | Impact | Effort | Priority |
|-------|--------|--------|----------|
| [Issue name] | High/Medium/Low | Low/Medium/High | P0/P1/P2 |

#### ‚úì Checklist Results:
- [‚úì or ‚úó] Semantic HTML
- [‚úì or ‚úó] ARIA attributes
- [‚úì or ‚úó] Keyboard navigation
- [‚úì or ‚úó] Focus management
- [‚úì or ‚úó] Form accessibility
- [‚úì or ‚úó] Color contrast
- [‚úì or ‚úó] Text alternatives
- [‚úì or ‚úó] Dynamic content
- [‚úì or ‚úó] Mobile/Touch
- [‚úì or ‚úó] Screen reader support
- [‚úì or ‚úó] Animations & Motion
- [‚úì or ‚úó] React-specific patterns

#### üìã Action Items:
1. [Specific actionable item with assignee if applicable]
2. [Specific actionable item]
3. [Specific actionable item]

IMPORTANT RULES:
- Be thorough - check EVERY accessibility aspect systematically
- Reference specific WCAG 2.2 criteria with level (A/AA/AAA) for each issue
- Include links to WCAG Understanding docs for major issues
- Provide complete, working code examples that can be copy-pasted
- Explain WHY each issue matters - be specific about affected user groups
- Give concrete examples: "Screen reader will announce 'button' with no label" vs "Missing label"
- Consider the mirai-ui project structure and conventions
- Follow existing test patterns from src/components/*/[Component].test.tsx
- Suggest tests using @mirai-ui/test utilities (render, screen, userEvent)
- If component is already excellent, celebrate it but suggest edge cases and enhancements
- Always consider: keyboard-only users, screen reader users, users with low vision, users with motor disabilities
- Check for both automated and manual testing recommendations
- Prioritize issues: P0 (blocks release) > P1 (high impact) > P2 (enhancement)
- Include estimated effort for each fix
- Be constructive and specific, not just critical
- Reference existing components as examples when relevant
- Recommend documenting accessibility decisions in code comments when non-obvious patterns are used
- Check test organization matches project conventions: Rendering, Interaction, Keyboard Navigation, States, Ref Forwarding

Context about mirai-ui:
- **Tech Stack:** React 19 + TypeScript
- **Styling:** Tailwind CSS 4.x + class-variance-authority (CVA)
- **Testing:** Vitest + Testing Library (@testing-library/react, @testing-library/user-event)
- **Test Utilities:** Import from @mirai-ui/test (provides render, screen, userEvent, customRender)
- **Semantic Colors:** Defined in src/styles/semantic-colors.css (use these for accessible color tokens)
- **Component Structure:** Each component has .component.tsx, .test.tsx, .types.ts, .variants.ts, .stories.tsx
- **Test Organization:** Tests use describe blocks: Rendering, Interaction, Accessibility, States, Ref Forwarding
- **Best Practices:** 
  - All interactive components must forward refs
  - All components must set displayName
  - Use native HTML elements when possible
  - Follow ARIA Authoring Practices Guide (APG) patterns
  - Semantic HTML over ARIA when possible (e.g., native <button> instead of div with role="button")
```

---

## How to Add This Command to Cursor

1. Open Cursor Settings (Cmd/Ctrl + ,)
2. Navigate to "Rules for AI" section
3. Add a new rule:
   - **Name:** Accessibility Audit
   - **Trigger:** `/a11y`
   - **Prompt:** [Copy the entire prompt above]
4. Save settings

## Usage

After adding the command, use it in one of these ways:

### Method 1: With Selected Code
1. Select component code in editor
2. Open chat
3. Type `/a11y`

### Method 2: With Open File
1. Open component file
2. Open chat  
3. Type `/a11y`

### Method 3: With Specific Request
```
/a11y Check the Input component for WCAG AA compliance
```

---

## Example Output

When you run `/a11y` on a component, you'll get a detailed report like:

```
üîç Component Analysis: Button

‚úÖ What's Well Implemented:
- Uses native <button> element (line 58) ‚úì
- Properly forwards ref for focus management (line 12)
- aria-disabled set correctly when disabled/loading (line 72)
- aria-busy announces loading state to screen readers (line 73)
- Keyboard support with Enter and Space (lines 33-55)
- displayName set for dev tools (line 91)
- Conditional icon rendering preserves accessibility (lines 79-85)

‚ö†Ô∏è Accessibility Issues Found:
1. üî¥ Critical: Missing aria-label prop for icon-only buttons
2. üü° Important: Loading spinner lacks aria-label
3. üü¢ Enhancement: Focus indicator could use semantic color tokens

üéØ Quick Wins (Easy Fixes):
1. Add aria-label prop to ButtonProps interface (~2 minutes)
2. Add aria-label to Spinner component (~1 minute)

üîß Detailed Recommendations:

**1. Icon-only buttons need text alternative** - üî¥ Critical

```tsx
// ‚ùå Current implementation (lines 14-27)
export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ leftIcon, rightIcon, children, ...props }, ref) => {
    // No aria-label support when children is empty
  }
);

// ‚úÖ Recommended implementation
export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ leftIcon, rightIcon, children, 'aria-label': ariaLabel, ...props }, ref) => {
    // Validate icon-only buttons have labels
    if (!children && !ariaLabel) {
      console.warn('Button: Icon-only buttons must have an aria-label');
    }
    
    return (
      <button
        ref={ref}
        aria-label={!children ? ariaLabel : undefined}
        {...props}
      >
        {leftIcon && <span aria-hidden="true">{leftIcon}</span>}
        {children}
        {rightIcon && <span aria-hidden="true">{rightIcon}</span>}
      </button>
    );
  }
);
```

**Why:** Screen readers will announce icon-only buttons as "button" with no context about what the button does. Users cannot understand the button's purpose.
**WCAG Criterion:** 4.1.2 Name, Role, Value (Level A)
**Reference:** https://www.w3.org/WAI/WCAG22/Understanding/name-role-value
**Affected Users:** Screen reader users (NVDA, JAWS, VoiceOver)
**Estimated Effort:** 15 minutes (add prop + tests)

[... more detailed recommendations ...]

üß™ Recommended Accessibility Tests:

**Add to `Button.test.tsx`:**

```tsx
describe('Button', () => {
  // ... existing test groups ...

  describe('States', () => {
    // ... existing state tests ...
    
    test('announces loading state to screen readers', () => {
      render(<Button loading>Submit</Button>);
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-busy', 'true');
      expect(button).toBeDisabled();
    });
  });

  // Add new test group for icon-only buttons
  describe('Icon-only buttons', () => {
    test('warns when icon-only button lacks aria-label', () => {
      const consoleSpy = vi.spyOn(console, 'warn');
      render(<Button leftIcon={<span>‚Üí</span>} />);
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Icon-only buttons must have an aria-label')
      );
    });

    test('accepts aria-label for icon-only buttons', () => {
      render(<Button leftIcon={<span>‚Üí</span>} aria-label="Next page" />);
      expect(screen.getByRole('button', { name: 'Next page' })).toBeInTheDocument();
    });

    test('hides icon from screen readers when label is provided', () => {
      const { container } = render(
        <Button leftIcon={<span data-testid="icon">‚Üí</span>} aria-label="Next">
          <span className="sr-only">Next page</span>
        </Button>
      );
      const icon = screen.getByTestId('icon');
      expect(icon.parentElement).toHaveAttribute('aria-hidden', 'true');
    });
  });
});
```

üìä Priority Summary:
- üî¥ Critical (blocks users): 1 - **Must fix before release**
- üü° Important (impacts UX): 1 - **Fix in next sprint**
- üü¢ Enhancements: 1 - **Nice to have**
- **Overall Accessibility Score:** 8.5/10 based on WCAG 2.2 Level AA

‚ö° Impact vs Effort Matrix:
| Issue | Impact | Effort | Priority |
|-------|--------|--------|----------|
| Icon-only aria-label | High | Low | P0 |
| Loading spinner label | Medium | Low | P1 |
| Semantic color tokens | Low | Medium | P2 |

‚úì Checklist Results:
- ‚úì Semantic HTML - Excellent use of native button
- ‚úì ARIA attributes - Good, needs icon-only support
- ‚úì Keyboard navigation - Fully implemented
- ‚úì Focus management - Good with ref forwarding
- N/A Form accessibility - Not a form component
- ‚ö† Color contrast - Needs verification with semantic tokens
- ‚úó Text alternatives - Missing for icon-only buttons
- ‚úì Dynamic content - Loading handled well
- ‚úì Mobile/Touch - Button sizing appropriate
- ‚úì Screen reader support - Good overall
- N/A Animations & Motion - No animations in button
- ‚úì React-specific patterns - Excellent ref/displayName usage

üìã Action Items:
1. Add aria-label prop support to ButtonProps interface
2. Add development warning for icon-only buttons without labels
3. Update Button.stories.tsx with icon-only examples
4. Add accessibility tests for icon-only scenario
5. Document icon-only button usage in Storybook docs
```

---

## Tips for Best Results

### When to Run `/a11y`

1. **Before committing** - Make `/a11y` part of your pre-commit checklist for new components
2. **After major changes** - Re-run when you modify component behavior or structure
3. **Regular audits** - Quarterly review of existing components to catch new issues
4. **Before release** - Final check before publishing new versions

### How to Use Effectively

1. **Start broad, then narrow**
   ```
   /a11y                                    # Check currently open component
   /a11y Check all form components          # Multiple components
   /a11y Focus on keyboard navigation only  # Specific aspect
   ```

2. **Combine with other commands**
   - `/a11y` first to identify issues
   - Implement fixes
   - Run tests with `pnpm test`
   - Review in Storybook

3. **Learn from patterns**
   - The explanations teach accessibility principles
   - Reference existing well-implemented components
   - Build a mental model of accessible patterns

4. **Manual testing**
   - Use `/a11y` for automated checks
   - Then manually test with:
     - **Keyboard only** - Unplug mouse/trackpad and navigate with Tab, Enter, Space, Arrow keys
     - **Screen reader** - Test with VoiceOver (Mac: Cmd+F5), NVDA (Windows, free), or JAWS
     - **Zoom to 200%** - Browser zoom should not break layout or hide content
     - **High contrast mode** - Enable OS high contrast mode to verify custom colors
     - **Reduced motion** - Test with prefers-reduced-motion enabled in browser DevTools
     - **Mobile touch** - Test on actual touch devices or mobile emulators

### Integration with Workflow

```bash
# 1. Create component
pnpm storybook  # Develop visually

# 2. Run accessibility audit
# Open component file, then in Cursor chat:
/a11y

# 3. Implement fixes from recommendations

# 4. Add tests
pnpm test:watch  # Use test examples from /a11y output

# 5. Verify in Storybook
# Check accessibility panel in Storybook

# 6. Manual testing
# Test with keyboard and screen reader
```

### Common Patterns

**For new components:**
```
/a11y Review [ComponentName] for WCAG 2.2 Level AA compliance and suggest improvements
```

**For existing components:**
```
/a11y Audit [ComponentName] and compare against ARIA Authoring Practices Guide
```

**For specific concerns:**
```
/a11y Check keyboard navigation and focus management for [ComponentName]
/a11y Verify screen reader announcements for [ComponentName]
/a11y Review form accessibility for [ComponentName]
```

---

## WCAG 2.2 Quick Reference

Key criteria to remember (Level AA focus):

| Criterion | Level | Description | Quick Check |
|-----------|-------|-------------|-------------|
| 1.4.3 Contrast (Minimum) | AA | 4.5:1 for text, 3:1 for large text | Use browser DevTools or contrast checker |
| 1.4.11 Non-text Contrast | AA | 3:1 for UI components | Check focus indicators, borders, icons |
| 2.1.1 Keyboard | A | All functionality via keyboard | Unplug mouse, navigate with Tab/Enter/Space |
| 2.4.3 Focus Order | A | Logical focus order | Tab through - order should match visual |
| 2.4.7 Focus Visible | AA | Visible focus indicator | Tab through - see where focus is |
| 2.4.11 Focus Not Obscured | AA | Focus not hidden by content | Check sticky headers don't cover focus |
| 2.5.7 Dragging Movements | AA | Alternative to dragging | Provide keyboard/click alternative |
| 2.5.8 Target Size (Minimum) | AA | 24x24px minimum | Check button/link sizes |
| 3.2.6 Consistent Help | A | Help in same location | Keep help links consistent |
| 3.3.2 Labels or Instructions | A | Form inputs labeled | Every input has visible label |
| 3.3.7 Redundant Entry | A | Don't re-ask same info | Auto-fill previously entered data |
| 3.3.8 Accessible Authentication | AA | No cognitive tests | Don't require puzzles, use copy/paste |
| 4.1.2 Name, Role, Value | A | Elements have accessible names | Use proper semantic HTML and ARIA |
| 4.1.3 Status Messages | AA | Status changes announced | Use role="status" or aria-live |

### Prefer Visible Labels

Always prefer visible text labels over `aria-label` when possible:

```tsx
// ‚úÖ Best - visible label
<Button>
  <TrashIcon aria-hidden="true" />
  Delete
</Button>

// ‚ö†Ô∏è OK - but visible label is better
<Button aria-label="Delete item">
  <TrashIcon />
</Button>

// ‚úÖ Good for icon-only when space is limited
<Button aria-label="Delete">
  <TrashIcon aria-hidden="true" />
</Button>
```

**Why?** Visible labels benefit everyone, not just screen reader users. Users with cognitive disabilities, low vision users, and mobile users all benefit from clear visible text.

## Related Commands

- `/test` - Generate tests (combine with a11y recommendations)
- `/review` - General code review
- `/refactor-clean` - Code cleanup (can include accessibility improvements)

---

## Additional Resources

### Project Documentation
- `docs/a11y-command.mdx` - Complete accessibility guidelines
- `docs/testing-guidelines.mdx` - How to write accessibility tests
- `src/test/` - Test utilities available in the project
- `src/components/Button/Button.test.tsx` - Example of comprehensive accessibility tests
- `src/styles/semantic-colors.css` - Accessible color tokens

### WCAG 2.2 Resources
- [WCAG 2.2 Guidelines](https://www.w3.org/WAI/WCAG22/quickref/) - Quick reference
- [Understanding WCAG 2.2](https://www.w3.org/WAI/WCAG22/Understanding/) - Detailed explanations
- [ARIA Authoring Practices Guide (APG)](https://www.w3.org/WAI/ARIA/apg/) - Design patterns
- [WebAIM Articles](https://webaim.org/articles/) - Practical accessibility guides

### Testing Tools
- [axe DevTools](https://www.deque.com/axe/devtools/) - Browser extension for automated testing
- [WAVE](https://wave.webaim.org/) - Web accessibility evaluation tool
- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - Chrome built-in audit
- [jest-axe](https://github.com/nickcolley/jest-axe) - Automated accessibility testing in tests

### Screen Readers
- **macOS:** VoiceOver (built-in, Cmd+F5 to toggle)
- **Windows:** [NVDA](https://www.nvaccess.org/) (free), [JAWS](https://www.freedomscientific.com/products/software/jaws/) (paid)
- **iOS:** VoiceOver (Settings ‚Üí Accessibility)
- **Android:** [TalkBack](https://support.google.com/accessibility/android/answer/6283677)

### Learning Resources
- [WebAIM Screen Reader Testing](https://webaim.org/articles/screenreader_testing/) - How to test with screen readers
- [Inclusive Components](https://inclusive-components.design/) - Accessible component patterns
- [A11y Project](https://www.a11yproject.com/) - Community-driven accessibility resources
- [MDN Accessibility](https://developer.mozilla.org/en-US/docs/Web/Accessibility) - Technical documentation

### Recommended Books
- "Accessibility for Everyone" by Laura Kalbag
- "Form Design Patterns" by Adam Silver
- "Inclusive Design Patterns" by Heydon Pickering

---

## Common Accessibility Issues & Quick Fixes

### Issue: Icon-only buttons with no label
‚ùå **Bad:**
```tsx
<button><IconTrash /></button>
```
‚úÖ **Good:**
```tsx
<button aria-label="Delete item"><IconTrash aria-hidden="true" /></button>
```

### Issue: Inputs without labels
‚ùå **Bad:**
```tsx
<input type="text" placeholder="Email" />
```
‚úÖ **Good:**
```tsx
<label htmlFor="email">Email</label>
<input id="email" type="text" />
```

### Issue: Error messages not associated
‚ùå **Bad:**
```tsx
<input type="email" />
<span className="error">Invalid email</span>
```
‚úÖ **Good:**
```tsx
<input 
  type="email" 
  aria-invalid="true"
  aria-describedby="email-error"
/>
<span id="email-error" role="alert">Invalid email</span>
```

### Issue: Custom checkbox without proper ARIA
‚ùå **Bad:**
```tsx
<div onClick={toggle}>{checked ? '‚òë' : '‚òê'}</div>
```
‚úÖ **Good:**
```tsx
<input type="checkbox" checked={checked} onChange={toggle} />
// Or for custom UI:
<div role="checkbox" aria-checked={checked} tabIndex={0} onKeyDown={handleKey} onClick={toggle}>
  {checked ? '‚òë' : '‚òê'}
</div>
```

### Issue: Loading state not announced
‚ùå **Bad:**
```tsx
<button disabled={loading}>
  {loading ? <Spinner /> : 'Submit'}
</button>
```
‚úÖ **Good:**
```tsx
<button disabled={loading} aria-busy={loading}>
  {loading ? <Spinner aria-label="Loading" /> : 'Submit'}
</button>
```

### Issue: Focus indicator removed
‚ùå **Bad:**
```css
button:focus {
  outline: none;
}
```
‚úÖ **Good:**
```css
button:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}
```

### Issue: Animations not respecting reduced motion preference
‚ùå **Bad:**
```css
.spinner {
  animation: spin 1s linear infinite;
}
```
‚úÖ **Good:**
```css
.spinner {
  animation: spin 1s linear infinite;
}

@media (prefers-reduced-motion: reduce) {
  .spinner {
    animation-duration: 2s;
    animation-timing-function: ease;
  }
}
```

---

## Troubleshooting

### `/a11y` not finding issues in obviously broken component

**Possible causes:**
1. Component not properly loaded in context
2. Need to be more specific in prompt
3. Component using uncommon patterns

**Solutions:**
- Ensure component file is open and focused
- Use more specific prompt: `/a11y Check this component for missing ARIA labels and keyboard support`
- Attach specific code sections with `@` mentions

### Too many false positives

**Solutions:**
- Review your component's use case - some patterns are intentional
- Clarify context: `/a11y This is a decorative component, check if it's properly hidden from screen readers`
- Focus on specific WCAG levels: `/a11y Check only WCAG Level A and AA compliance`

### Want to focus on specific accessibility aspects

**Use targeted prompts:**
```
/a11y Check only keyboard navigation
/a11y Review only ARIA attributes
/a11y Focus on color contrast issues
/a11y Verify screen reader announcements
```

### Getting outdated recommendations

This command uses WCAG 2.2 standards. If recommendations seem outdated:
- Verify the component follows current React patterns
- Check that semantic tokens from `semantic-colors.css` are used
- Ensure the prompt in Cursor settings matches this documentation

---

## Best Practices for Documenting Accessibility

When implementing accessibility features, document your decisions in code:

### JSDoc Comments for Complex Patterns

```tsx
/**
 * Custom checkbox component with full keyboard and screen reader support.
 * 
 * @accessibility
 * - Uses native input[type="checkbox"] for proper semantics
 * - Visual checkbox is aria-hidden, real input is visually hidden
 * - Supports label association via htmlFor/id and aria-labelledby
 * - Keyboard: Space to toggle (native behavior)
 * - Screen readers: Announces as "checkbox" with checked state
 * 
 * @see https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/
 */
export const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(...);
```

### Inline Comments for Non-Obvious Patterns

```tsx
// Hide decorative icon from screen readers, label is provided by button text
<span aria-hidden="true">{leftIcon}</span>

// Focus trap: Prevent tab from escaping modal
if (e.key === 'Tab' && !modalRef.current?.contains(e.relatedTarget)) {
  e.preventDefault();
  firstFocusableElement.focus();
}
```

### Component Documentation

Include accessibility information in your Storybook docs and README:

```markdown
## Accessibility

- **Keyboard Navigation**: Space/Enter to select, Tab to navigate
- **Screen Reader Support**: Announces as "checkbox, checked/unchecked"
- **Focus Management**: Visible focus indicator with 3:1 contrast ratio
- **ARIA Attributes**: Uses native checkbox semantics, no custom ARIA needed
- **WCAG 2.2 Level AA Compliant**

### Icon-only Usage

When using icon-only buttons, always provide an `aria-label`:

\`\`\`tsx
<Button leftIcon={<TrashIcon />} aria-label="Delete item" />
\`\`\`
```

## Version History

**v2.1** (Current)
- Added WCAG 2.2 new criteria (2.5.7, 3.2.6, 3.3.8)
- Added Animations & Motion section with prefers-reduced-motion guidance
- Enhanced test examples to match project conventions
- Added reduced motion examples
- Improved manual testing guidance
- Added documentation best practices

**v2.0**
- Updated to WCAG 2.2 compliance
- Added React-specific patterns section
- Enhanced output format with Quick Wins and Impact Matrix
- Added detailed test recommendations
- Improved project-specific context
- Added WCAG criterion links

**v1.0**
- Initial release with WCAG 2.1 compliance
- Basic checklist and recommendations

---

## Feedback & Improvements

Have suggestions for improving this command? Consider:
1. Testing with real components and noting gaps
2. Documenting common edge cases
3. Sharing successful accessibility patterns
4. Contributing to `docs/a11y-command.mdx`

